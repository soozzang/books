# ✍🏻 06. static 제대로 한번 써 보자.

## static의 특징
static이라는 단어는 '정적인, 움직이지 않는'이라는 의미이다.

자바에서 static으로 지정했다면, 해당 메서드나 변수는 정적이다.

클래스내에 static으로 선언한 변수를 '클래스 변수'라고 한다. 그 변수는 '객체의 변수'가 되는게 아니라 '클래스의 변수'가 되기 때문이다.

100개의 동일 클래스의 인스턴스를 생성하더라도 모든 객체가 해당 클래스의 특정 static 변수에 대해선 `동일한 주소의 값을 참조`한다.

그리고, static 초기화 블록이라는 것이 있다. 많은 사람들이 알고 있겠지만, 다시 알아보자.

static 초기화 블록은 클래스 어느곳에나 지정할 수 있다. 이 static 블록은 클래스가 `최초 로딩될 때` 수행되므로 `생성자 실행과 상관없이 수행`된다.

또, 여러번 사용할 수 있으며, 마지막에 사용하여 지정한 값을 갖게 된다.

static 블록은 순차적으로 읽혀진다는 뜻이다.

static의 특징은 다른 JVM에서는 static이라고 선언해도 다른 주소나 다른 값을 참조하지만, 하나의 JVM이나 WAS인스턴스에서는 같은 주소에 존재하는 값을 참조한다는 것이다.

`그리고 GC의 대상도 되지 않는다.`

그러므로 static을 잘 사용하면 성능을 뛰어나게 향상시킬 수 있지만, 잘못 사용하면 예기치 못한 결과를 초래하게 된다.

특히 웹 환경에서 static을 잘못 사용하다가는 여러 쓰레드에서 하나의 변수에 접글할 수도 있기 때문에 데이터가 꼬이는 큰 일이 발생할 수 있다.

## static 잘 활용하기
먼저 static을 잘 활용하기 위해 간단히 사용법을 알아보자.

### 자주 사용하고 절대 변하지 않는 변수는 final static으로 선언하자
만약 자주 변경되지 않고, 경우의 수가 단순한 쿼리 문장이 있다면 final static이나  static으로 선언하여 사용하자.

자주 사용되는 로그인 관련 쿼리들이나 간단한 목록 조회 쿼리를 final static으로 선언하면 적어도 1바이트 이상의 객체가 GC 대상에 포함되지 않는다.

또한 JNDI 이름이나 간단한 코드성 데이터들을 static으로 선언해 놓으면 편하다.

### 설정 파일 정보도 static으로 관리하자
클래스의 객체를 생성할 때마다 설정 파일을 로딩하면 엄청난 성능 저하가 발생하게 된다. 이럴땐 반드시 static으로 데이터를 읽어서 관리해야 한다.

### 코드성 데이터는 DB에서 한 번만 읽자
큰 회사의 부서 코드나 큰 쇼핑몰의 상품 코드처럼 양이 많고 자주 바뀔 확률이 높은 데이터를 제외하고, 부서가 적은 회사의 코드나, 건수가 그리 많지 않되 조회 빈도가 높은 코드성 데이터는 DB에서 한 번만 읽어서 관리하는게 성능 측면에서 좋다.

## static 잘못 쓰면 이렇게 된다
먼저 잘못 만들어진 쿼리 관리용 클래스를 보자.

```java
import java.io.FileReader;
import java.util.HashMap;

public class BadQueryManager {
    private static String queryURL = null;

    public BadQueryManager(String badUrl) {
        queryURL = badUrl;
    }

    public static String getSql(String idSql) {
        try {
            FileReader reader = new FileReader();
            HashMap<String, String> document = reader.read(queryURL);
            return document.get(idSql);
        } catch (Exception e) {
            System.out.println(e);
        }
        return null;
    }
}
```

queryURL이라는 문자열을 static으로 지정해 놓았다.

이 문자열에는 쿼리가 포함된 파일의 이름과 위치가 지정되어 있다. 문자열이 있는 생성자로 이 클래스 객체를 생성하면 쿼리 파일이 지정된다.

getSql(String idSql) 메서드에서는 DAO에서 쿼리를 요청하면, 해당 쿼리 파일을 읽어서 리턴해준다.

이 메서드 또한 `static`으로 지정되어 있다.

먼저 이 소스를 수행하면, 제대로 된 결과가 나올지 생각해 보자.

처음엔 수행이 된다. 쿼리가, 같은 파일에 있는 화면에서는 수행이 되고, 만약 어떤 화면의 수행 결과가 다른 파일의 쿼리인 경우에도 처음에 그 화면이 호출되었다면, 정상적으로 수행될 것이다.

물론 파일을 읽어야 하므로 화면의 응답 속도는 느릴 것이다.

`그런데 만약 어떤 화면에서 BadQueryManager의 생성자를 통해서 queryURL을 설정하고 getSql() 메서드를 호출하기 전에, 다른 queryURL을 사용하는 화면의 스레드에서 BadQueryManager의 생성자를 호출하면 어떤 일이 발생할까?`

그때부터는 시스템이 오류를 발생시킨다. 먼저 호출한 화면에서는 처음의 URL을 유지하고 있을 것이라고 생각하고 getSql() 메서드를 호출하겠지만 이미 그땐 값이 변경된 후다.

<br>

getSql() 메서드와 queryURL을 static으로 선언한 것이 잘못된 부분이다. 

직접 접근할 수 있도록 static으로 선언하였는데, 그로 인해 문제가 발생한 것이다.

웹 환경이기 때문에 여러 화면에서 호출할 경우에 queryURL은 그때 그때 바뀌게 된다. 다시 말하면 queryURL은 static으로 선언했기 때문에 `클래스의 변수`이지 `객체의 변수`가 아니다.

`모든 스레드에서 동일한 주소를 가리키게 되어` 문제가 발생한 것이다.

어떤 언어로 프로그래밍을 하든 파일 IO가 발생하면 느려진다. 이 소스는 쿼리를 한 번 호출하기 위해 매번 파일을 읽을 수 밖에 없는 구조기 때문에 IO가 발생하면서 대기하는 IO wait가 발생하는 걸 피할 수 없다.

static을 잘못 사용한 또 다른 예를 보자.

```java
// 생략
private static boolean successFlag;
// 생략
```

이 소스는 서블릿에서 응시자의 합격 여부를 잠깐 담아 놓기 위해 successFlag로 지정해 놓은 부분이다.

어떤 일이 발생했을까? 물론 이 소스는 개발자 본인의 PC에서 테스트할 때는 전혀 문제가 되지 않는다. 그리고 성능 테스트를 하거나 통합 테스트를 하더라도 문제점을 쉽게 발견할 수가 없다.

그러나 만약 수십 명이 동시에 자신의 정보를 확인하기 위해 위의 서블릿을 호출하는 경우를 생각해 보자.

successFlag를 true로 처리해 놓은 상황에서 다른 사용자의 요청이 처리되어 false로 바뀐다면, 그 사람은 완전히 다른 결과를 받게 된다.

## static과 메모리 릭
static으로 선언한 부분은 `GC`가 되지 않는다.

그럼 만약 어떤 클래스에 데이터를 Vector나 ArrayList에 담을 때 해당 Collection 객체를 static으로 선언하면 어떻게 될까?

만약 지속적으로 해당 객체에 데이터가 쌓인다면, 더 이상 GC가 되지 않으면서 시스템은 OOM을 발생시킨다.

즉, 시스템을 재시작하며, 해당 인스턴스는 더 이상 서비스할 수 없다.

## 정리하며
static은 원리를 알고 잘 사용하면 시스템의 성능을 향상시킬 수 있는 마법의 예약어다.

하지만 잘못 사용하면 돌이킬 수 없는 일, 시스템이 다운되거나 예기치 못한 결과가 나올 수 있다.

`static은 반드시 메모리에 올라가며 GC의 대상이 되지 않는다.`

객체를 다시 생성한다고 해도 그 값은 초기화 되지 않고 해당 클래스를 사용하는 모든 객체에서 공유하게 된다.

만약 static을 사용하는 것이 걱정된다면, 아예 쓰지말라. 모르고 시스템이 잘못되는 것보다 아예 안 쓰는 것이 더 안전하다.
